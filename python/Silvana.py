from definizioni import *
from coordinateoggetto import *
from immagini import *
import funzionimappa as fmap
from move import *
import cv2
import numpy as np
import math
from braccio import *


# Function to follow a path generated by pathfinding
def follow_path(path):
    global robot_pos, robot_angle,offset

    # Iterate through each tile (y, x) in the path
    for (y, x) in path:
        while True:
            target_pos =fmap.mat_to_pixel(y,x) # Convert grid to pixel position
            # Compute angle
            angle_to_target = fmap.calcola_angolo(robot_pos, target_pos)
            angle_diff = (angle_to_target - robot_angle + 360) % 360

            if angle_diff > 180:
                angle_diff -= 360 # Normalize angle difference to [-180, 180]

            # Ruota verso la destinazione
            robot_angle = move_rotation(angle_diff,ser,btsock,offset)
            fmap.visualizza_mappa(robot_angle,robot_pos) # Update map visualization
            cv2.waitKey(10)
            # Save starting tile and initialize current_tile
            old=fmap.pixel_to_mat(robot_pos[0], robot_pos[1])
            current_tile=old
            # Move forward until a new tile is reached
            while current_tile==old and current_tile!=[y,x]:
                robot_angle=move_linear('forward', robot, 0,robot_pos, robot_angle,ser,btsock,offset)
                fmap.visualizza_mappa(robot_angle,robot_pos)
                key = cv2.waitKey(10)
                current_tile = fmap.pixel_to_mat(robot_pos[0], robot_pos[1]) # Update current tile position

            # Exit loop if destination tile reached
            if current_tile == (y, x):
                print(f"Casella {y}, {x} raggiunta")
                break
# Function to move robotic arm to the side (prepare for interaction)
def posizione_laterale():
    ser.write(b'b000,') # b = base 
    time.sleep(0.5)
    ser.write(b'v150,') # v = shoulder
    time.sleep(0.5)
    ser.write(b'x090,') # x = wrist
    time.sleep(0.5)
    ser.write(b'c090,') # c = elbow
    time.sleep(0.5)
#--------------------------------------------------------------------------------
offset=0
robot=spider
btsock = 0
if robotm[0]==1: # If robot uses serial
    ser=init_connessione() # Start serial connection
    ser.write(b'g,')
    offset=read_angle_from_serial(ser) # Read current heading (for offset calibration)
time.sleep(3)
print(offset)
robot_angle=0
cam_thread = CameraThread()
cam_thread.start()
modello('yolov8s.pt') # Load YOLOv8s model for person detection
try:
    # --- STEP 1: Wait until a person approaches the robot (within 50 cm) ---
    print("Aspetto di vedere qualcuno...")
    while True:
        distance=None
        color_image, depth_image = cam_thread.get_frames()
        if color_image is not None and depth_image is not None:
            center=[320,240] # Center of the frame
            distance = calculate_distance(depth_image, center[0], center[1])
            if distance is not None and distance<50:
                break
    robot_angle = move_rotation(180,ser,btsock,offset) # Rotate to face the stage center (180 degrees)
    
    # --- STEP 2: Detect a person and calculate their position on the map ---
    while True:
        distance=None
        color_image, depth_image = cam_thread.get_frames()
        if color_image is not None and depth_image is not None:
            center=visualizza_yolo(color_image,"person") # Detect a person with YOLO
            if center is not None:
                print(center,distance)
                distance = calculate_distance(depth_image, center[0], center[1])

                print(center,distance)
            if distance is not None and distance<400:
                break
    punto_finale=dove_object(robot_pos,center[0],distance,robot_angle) # Convert person position from image space to world coordinates
    # --- STEP 3: Navigate to the person using pathfinding ---
    start = fmap.pixel_to_mat(robot_pos[0], robot_pos[1])
    goal = fmap.pixel_to_mat(punto_finale[0],punto_finale[1])
    path_to_start = fmap.a_star_search(start, goal, obstacle_map)
    if path_to_start:
        follow_path(path_to_start)

    ser.write(b'W,')
    ser.write(b'W,')
    ser.write(b'w,')

    time.sleep(4)

    # --- STEP 4: Rotate back toward the audience ---
    ser.write(b'g,') # Ask robot for current angle
    robot_angle=read_angle_from_serial(ser)
    angle_diff = (270 - robot_angle + 360) % 360
    if angle_diff > 180:
        angle_diff -= 360
    robot_angle = move_rotation(angle_diff,ser,btsock,offset)

    ser.write(b'W,')
    ser.write(b'W,')
    ser.write(b'w,')
    
    # --- STEP 5: Prepare for glass scene (move arm to side) ---
    posizione_laterale()
    time.sleep(3)
    ser.write(b'z000,')
    time.sleep(3)
    modello('best.pt') # Load object detection model
    # --- STEP 6: Detect the glass ---
    while True:
        distance=None
        color_image, depth_image = cam_thread.get_frames()
        if color_image is not None and depth_image is not None:
            center=visualizza_yolo(color_image,"S") # Detect the letter on the glass
            if center is not None:
                distance = calculate_distance(depth_image, center[0], center[1])
                if distance is not None and distance<100:
                    break
    # Draw detected object
    cv2.circle(color_image, center, 2 , (0, 255, 0), 2)
    cv2.imshow('Color Frame', color_image)

    # --- STEP 7: Calculate target height and angle from robot to object ---
    t_ang,t_alt=target(center,distance)
    print(t_alt)
    t_alt += 10 # Adjust for glass height offset
    print(t_ang,t_alt,distance)
    angoli=find_closest_configuration(distance,t_alt)
    print(angoli)
    draw_segments(angoli)

    # --- STEP 8: Move arm to take the glass ---
    muovi_braccio(ser,angoli)
    stringa = f"b{t_ang:03d}," 
    ser.write(stringa.encode())   # Rotate base to target angle
    time.sleep(1.5)

    ser.write(b'z095,') # close the hand
    time.sleep(1.5)

    # --- STEP 9: Bring glass to mouth ---
    ser.write(b'c090,') #80kg
    ser.write(b'f120,')
    ser.write(b'v125,') #150kg
    ser.write(b'c145,') #80kg
    time.sleep(1)
    ser.write(b'x135,')#polso
    time.sleep(4)
    # --- STEP 10: Move glass away from mouth ---
    ser.write(b'v115,')
    ser.write(b'c135,')
    time.sleep(1)
    ser.write(b'f105,')
    time.sleep(1)
    ser.write(b'x125,')
    time.sleep(1)
    # --- STEP 11: Return cup to mouth again ---
    ser.write(b'c090,')
    ser.write(b'f120,')
    ser.write(b'v125,')
    ser.write(b'c145,')
    time.sleep(1)
    ser.write(b'x135,')
    time.sleep(4)
    # --- STEP 12: Place the cup down on the table ---
    ser.write(b'v125,')
    ser.write(b'c055,')
    time.sleep(1)
    ser.write(b'x095,')
    time.sleep(1)
    ser.write(b'f093,')
    ser.write(b'z000,')
    time.sleep(2)
    posizione_laterale()
    time.sleep(5)
    # --- STEP 13: Wait until the person grabs the cup (very close) ---
    while True:
        distance=None
        color_image, depth_image = cam_thread.get_frames()
        if color_image is not None and depth_image is not None:
            center=[320,240]
            distance = calculate_distance(depth_image, center[0], center[1])
            if distance is not None and distance<20:
                break
                
    # --- STEP 14: Turn to 260Â° (face Silvestro) ---
    ser.write(b'g,')
    robot_angle=read_angle_from_serial(ser)
    angle_diff = (260 - robot_angle + 360) % 360
    if angle_diff > 180:
        angle_diff -= 360
    robot_angle = move_rotation(angle_diff,ser,btsock,offset)

finally:
    # --- Cleanup: close all OpenCV windows and stop camera thread ---
    cv2.destroyAllWindows()
    cam_thread.stop()
